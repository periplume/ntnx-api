#!/usr/bin/env bash
# desc: install/run scipt for dockerized NTNX RestAPI dev env
# author: Jason Lindemuth
# source: https://github.com/periplume/ntnx-api
# version 1.0

scriptname=${0##*/}
logfile=$scriptname.log
rawgit=https://github.com/periplume/ntnx-api/raw/master
rawgitself=$rawgit/$scriptname
image=periplume/ntnx-api:v1

# set logging
# 0 for nothing (silent)
# 1 to log to $scriptname.log
debug=1

# tools we need in this script
commands="date wget curl git docker diff"

usage () {
	cat << EOF
usage: $scriptname
$ $scriptname $BLUE check $RESET      (test the environment and identify missing tools)
$ $scriptname $BLUE build $RESET      (build the docker image)
$ $scriptname $BLUE run $RESET        (run the container and attach to the shell)
$ $scriptname $BLUE lucky $RESET      (roll the dice and run it all)
EOF
exit
}

spinner () {
	# fancy whirligig to indicate we're waiting on a long running task
	# care of http://fitnr.com/showing-a-bash-spinner.html
	local pid=$1
	local delay=0.75
	local spinstr='|/-\'
	while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
		local temp=${spinstr#?}
		printf "[ %c ]  " "$spinstr"
		local spinstr=$temp${spinstr%"$temp"}
		sleep $delay
		printf "\b\b\b\b\b\b\b"
	done
	printf "    \b\b\b\b"
}

checkCommand () {
	# desc: check for the existence and executability of a command
	# arg: command name
	# success: return 0
	# failure: return 1
	if [ -x "$(command -v $1)" ]
	then
		logevent "f:$FUNCNAME: true[$?]: $1 exists and is executable"
		return 0
	else
		logevent "f:$FUNCNAME: false[$?]: $1 missing or not executable"
		return 1
	fi
}

isOnline () {
	# desc: determine if we're ONLINE
	# args: none
	# success: return 0 if online
	# failure: return 1 if offline
	# TODO: assumes google.com = online; this should be improved
	if [ $wget_exists = 0 ]
	then
		wget -q --spider http://www.google.com
	elif [ ! $wget_exists = 0 ] && [ $curl_exists = 0 ]
	then
		curl -sSf http://www.google.com > /dev/null 2>&1
	else
		logevent "f:$FUNCNAME: error: missing wget and curl"
		return 1 
	fi
	if [ $? = 0 ]
	then
		logevent "f:$FUNCNAME: true[$?]: google.com is reachable"
		return 0
	else
		logevent "f:$FUNCNAME: false[$?]: google.com is not reachable"
		return 1
	fi
}

isScriptCurrent () {
	# desc: compare this script to the git master version
	# args: none
	# success: return 0 if files are same
	# failure: return 1 if files are different
	url=$rawgitself
	if [ $wget_exists = 0 ]
	then
		logevent "f:$FUNCNAME: info: fetching install from raw github with wget"
		wget -O install.gitmaster $url > /dev/null 2>&1
	elif [ ! $wget_exists = 0 ] && [ $curl_exists = 0 ]
	then
		logevent "f:$FUNCNAME: info: fetching install from raw github with curl"
		curl -L -o install.gitmaster $url > /dev/null 2>&1
	fi
	if [ $? = 0 ]
	then
		logevent "f:$FUNCNAME: true[$?]: install fetched, comparing with local copy"
		diff -q install install.gitmaster > /dev/null 2>&1
		if [ $? = 0 ]
		then
			logevent "f:$FUNCNAME: true[$?]: local and gitmaster are the same"
			return 0
		else
			logevent "f:$FUNCNAME: false[$?]: local and gitmaster differ"
			return 1
		fi
	else
		logevent "f:$FUNCNAME: false[$?]: could not fetch install"
		return 1
	fi
}

timestamp () {
	# desc: return a timestamp for logging
  # args: none
	# return format: 'YYYY-MM-DD HH:MM:SS SECONDS-SINCE-1970'
  date '+%F %T %s'
}

logevent () {
	# desc: logging facility
  # $@: one arg (multi word) the log message
  # logs event to global $logfile if debug=1
	if [ $debug = 0 ]
	then
		return 0
	elif [ $debug = 1 ]
	then
		echo "[$(timestamp)] $scriptname $@" >> $logfile
	fi
}

colorize () {
	# desc: rudimentary term inquiry to set output colorization
	# args: none
	if [ -x "$(command -v tput)" ]
	then
		logevent "f:$FUNCNAME: true[0]: tput exists and is executable, setting colors"
		if [ $(tput colors) = 256 ]
		then
			logevent "f:$FUNCNAME: true[0]: tput reports 256 colors; setting color VAR tags"
			GREEN="$(tput setaf 2)"
			YELLOW="$(tput setaf 3)"
			RED="$(tput setaf 1)"
			BLUE="$(tput setaf 4)"
			RESET="$(tput setaf 15)"
		elif [ $(tput colors) = 8 ]
		then
			logevent "f:$FUNCNAME: true[0]: tput reports 8 colors; setting color VAR tags"
			GREEN="$(tput setaf 2)"
			YELLOW="$(tput setaf 3)"
			RED="$(tput setaf 1)"
			BLUE="$(tput setaf 4)"
			RESET="$(tput setaf 8)"
		else
			logevent "f:$FUNCNAME: err[1]: tput colors reports number other than 8 or 256"
		fi
	fi
}

checkEnv () {
	# desc: run tests to determine if we can run here
	# args: none
	# return 0 if PASS
	# return 1 if FAIL
	for CMD in $commands
	do
		var_name=${CMD}_exists
		checkCommand $CMD
		if [ $? = 0 ]
			then
			eval ${var_name}='0'
		else
			eval ${var_name}='1'
		fi
		if [ ${!var_name} = 0 ]
		then
			echo "[$GREEN ${!var_name} $RESET] $CMD exists"
		# funky business to handle "need to have" vs "nice to have"
		#elif [ "$var_name" = "git_exists" ]
		#then
		#	echo "[$YELLOW ${!var_name} $RESET] $CMD missing, will use wget|curl instead"
		else
			if [ "$var_name" = "wget_exists" ]
			then
				checkCommand curl
				if [ $? = 0 ]
				then
					echo "[$YELLOW ${!var_name} $RESET] $CMD missing, will use curl instead"
				else
					echo "[$RED ${!var_name} $RESET] $CMD missing: please install $CMD"
					CHECKOK=1
				fi
			else
				echo "[$RED ${!var_name} $RESET] $CMD missing: please install $CMD"
				CHECKOK=1
			fi
		fi
	done
	if [ -z $CHECKOK ]
	then
		echo "$GREEN PASS $RESET command line tools test passed"
		isOnline
		if [ $? = 0 ]
		then
			ONLINE=0
			echo "[$GREEN $? $RESET] ONLINE mode is true"
			isScriptCurrent
			if [ $? = 0 ]
			then
				echo "[$GREEN $? $RESET] script appears to be latest"
			else
				echo "[$YELLOW $? $RESET] script $YELLOW differs $RESET from git master"
			fi
		else
			ONLINE=1
			echo "[$YELLOW $ONLINE $RESET] ONLINE mode is false"
			echo "[$YELLOW 1 $RESET] WARN: cannot test if script is current"
		fi
		return 0
	else
		echo "$RED FAIL $RESET command line tools test failed; install missing tools"
		return 1
	fi
}

fetchFile () {
	# desc: fetch a file from the github repository
	# args: filename (per github ntnx-api repo)
	whichFetch
	if [ $? = 0 ]
	then
		fetchpre="wget -q "
	elif [ $? = 1 ]
	then
		fetchpre="curl -OL "
	else
		return 1
	fi
	for file in $files
	do
		eval $fetchpre $rawgit/$file > /dev/null 2>&1
	done
}

whichFetch () {
	# desc: return preferred http file transfer tool
	# args: none
	# return 0 for wget
	# return 1 for curl
	# return 2 for none found
	checkCommand wget
	if [ $? = 0 ]
	then
		return 0
	elif checkCommand curl
	then
		if [ $? = 0 ]
		then
			return 1
		else
			return 2
		fi
	fi
}

buildImage () {
	# desc: build the docker image
	# args: none
	# return 0 if success
	# return 1 if build reports error
	echo "[$GREEN $? $RESET] building docker image...may take some time; (to watch: tail -f dockerbuild.log)"
	(docker build --tag=$image . > dockerbuild.log 2>&1) &
	spinner $!
	echo "[$GREEN $? $RESET] success: run 'install run' next"
}

run () {
	# run and attach to the container
	echo "$GREEN PASS $RESET all tests passed...launching container now"
	for seconds in 3 2 1
	do
		if [ $seconds = 3 ]
		then
			COUNTCOLOR=$RED
		elif [ $seconds = 2 ]
		then
			COUNTCOLOR=$YELLOW
		else
			COUNTCOLOR=$GREEN
		fi
		echo -ne "[$GREEN OK $RESET] launching NTNX-API container in $COUNTCOLOR $seconds $RESET...\r"
		sleep 1
	done
	clear
	docker run -v $(pwd)/data:/nutanix/data -it $image
}

#
# MAIN
#
# test for term colors and set color VARS accordingly
colorize

# read the command arguments
if [ $# -eq 0 ];
then
  usage
else
  while [ $# -gt 0 ]
  do
    case "$1" in
      check)
        if [ $# -gt 1 ]
				then
					usage
        else
					echo "TESTING environment for required tools and conditions..."
					checkEnv
					if [ $? = 0 ]
					then
						echo "$GREEN PASS $RESET run 'install build' next"
						exit 
					else
						echo "$RED FAIL $RESET please install the missing tools"
						exit
					fi
				fi
        ;;
			build)
        if [ $# -gt 1 ]
				then
					echo "ERROR: build takes no arguments"
					usage
        else
					buildImage
				fi
				shift
				;;
			run)
				run
				shift
				;;
			lucky)
				if [ $# -gt 1 ]
				then
					usage
				else
					checkEnv
					fetchFile Dockerfile
					buildImage
					run
				fi
				shift
				;;
			*)
				usage
		esac
	done
fi

